/***********************************************************************/
/*                                                                     */
/*  FILE        :TEST2.c                                               */
/*  DATE        :Thu, Jan 16, 2025                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :Other                                                 */
/*                                                                     */
/*  This file is generated by KPIT GNU Project Generator.              */
/*                                                                     */
/***********************************************************************/
         
																							
																							
#include "vars.h"


//#define USE_METRIC_CAN_PATCH

#define BASE_FUEL_AIR_RATIO			0.07196f
#define ETHANOL_CONTENT_MIN			0.0f
#define ETHANOL_CONTENT_MAX			100.0f
#define CRANKING_FUEL_MULT_MIN		1.0f
#define CRANKING_FUEL_MULT_MAX		4.0f


//CAN setup
const CAN_Message_Setup_t flex_can_setup __attribute__ ((section ("FlexCANStruct"))) = {
	flex_sensor_id,
	0x1,
	0x22,
	0x8,
	0x0,
	flex_message_ram_start,
	0x1000000
};

#ifdef USE_METRIC_CAN_PATCH
const CAN_Message_Setup_t metrics_can_setup __attribute__ ((section ("can41txPatch_CANStruct"))) = {
	metrics_can_id,
	0x0,
	0x09,
	0x8,
	0x0,
	metrics_can_ram_start,
	0x1000000
};
#endif


//CAN unpack
void flexCANUnpack(void) __attribute__ ((section ("Flex_CAN_Unpack_Address")));

//Inits for flex based vars
void initFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Main for flex based function
void runFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Gets the ethanol content and applies to globals
void getFlexMetrics(void) __attribute__ ((section ("RomHole_ForCode")));

//Calculates timing adders
void calcTimingAdders(void) __attribute__ ((section ("RomHole_ForCode")));

//Calculates cranking fuel multipliers
void getCrankingFuelMult(void) __attribute__ ((section ("RomHole_ForCode")));

//Overwrites OEM cranking IPW function
void setCrankingInjectorPulseTime_FlexFuel(void) __attribute__ ((section ("RomHole_ForCode")));

//Get Ethanol Content from CAN message
void getEthanolContent(void) __attribute__ ((section ("RomHole_ForCode")));


//Main function for simulation

#define NO_DEBUG

#ifdef NO_DEBUG
float func(void) __attribute__ ((section ("RomHole_ForCode")));
unsigned short i __attribute__ ((section ("RAMHole_forVariables"))) = 0U;
#define uds_pid_data_rx_MAYBE					((short*)0xffffcffe)
#define pid_AND_val								((short*)0xffffd1c8)
#endif

const float ethanol_content_sample_thresh_rpm __attribute__ ((section ("RomHole_calibrations"))) = 11000.0f;		//Default off
const float ethanol_content_sample_thresh_load __attribute__ ((section ("RomHole_calibrations"))) = 2.750f;			//Default off

//TODO: These need to not be random RAM vars
float fuel_air_ratio __attribute__ ((section ("RAMHole_forVariables"))); 
float fuel_air_ratio_filtered __attribute__ ((section ("RAMHole_forVariables"))); 
float timing_mult  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_trailing  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_leading  __attribute__ ((section ("RAMHole_forVariables"))); 
float ethanol_content_pcnt __attribute__ ((section ("RAMHole_forVariables")));
float ethanol_content_last_valid_pcnt __attribute__ ((section ("RAMHole_forVariables")));
char flex_can_valid __attribute__ ((section ("RAMHole_forVariables")));
char flex_can_valid_prevLoop __attribute__ ((section ("RAMHole_forVariables")));
long alive_count __attribute__ ((section ("RAMHole_forVariables")));
float fuel_air_ratio_FF __attribute__ ((section ("RAMHole_forVariables")));//16ms update rate ish
float timing_mult_filtered __attribute__ ((section ("RAMHole_forVariables")));
float timing_mult_FF __attribute__ ((section ("RAMHole_forVariables")));//16ms update rate ish
float cranking_fuel_mult __attribute__ ((section ("RAMHole_forVariables")));


#ifdef USE_METRIC_CAN_PATCH
char grom_can_tx_patch_tx_count __attribute__ ((section ("RAMHole_forVariables"))) = 0U;
int engine_load_for_metrics_can __attribute__ ((section ("RAMHole_forVariables")));
//int front_o2_lambda_for_metrics_can __attribute__ ((section ("RAMHole_forVariables")));
float engine_load_for_can_g_rev __attribute__ ((section ("RAMHole_forVariables")));
#endif

char flex_can_timeout_counts  __attribute__ ((section ("Flex_CAN_Timeout_Val"))) = 100; //30ms-ish task rate for can timers

//Setup patches for new adder pointers 
long timing_adder_trailing_ptr  __attribute__ ((section ("TrailingPointerPatch"))) = &timing_adder_trailing;
long timing_adder_leading_ptr __attribute__ ((section ("LeadingPointerPatch")))  = &timing_adder_leading;

//Patch in function address for new cranking injection function
long cranking_injector_pw_func_ptr __attribute__ ((section ("FlexCrankingInjectorPWPatch")))  = &setCrankingInjectorPulseTime_FlexFuel;

#ifdef USE_METRIC_CAN_PATCH
long can41TXPackPatch_ptr __attribute__ ((section ("can41TXPackPatch")))  = &can41GROMPack;
#endif

#ifdef NO_DEBUG

void SetValues() __attribute__ ((section ("Misc")));

void SetValues() 
{
	
	*engine_load_g_rev = 0.04f;
	*engine_speed_rpm = 0.0f;
	*coolant_temp_degC = 1.0f;
	ethanol_content_pcnt = 100.0f;
	*flex_message_byte0 = 0x12;
	*engine_running_bool = 0;
	*coolant_temp_post_fault_detection_degC = -35.0f;
	//UDS Sim
	*uds_pid_data_rx_MAYBE = 0x55C;
	*pid_AND_val = 0x1234;
}

void delay_ms(unsigned int ms)
{
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 1000; j++) {
            __asm("NOP");  // No Operation instruction, just to add some delay
        }
    }
}

float func(){
	
	//highLevelInit();
	initFlexFuelCalcs();
	
	//NOTE: Dumping shit in here as an init
	//engine_load_for_can_g_rev = *engine_load_g_rev;
	//engine_load_for_metrics_can = 0U;
	//grom_can_tx_patch_tx_count = 0U;
	
	while(1){
		SetValues();
		setCrankingInjectorPulseTime_FlexFuel();
		//calcTimingAdders();
		//can41GROMPack();
		//flexCANUnpack();	//NOTE: This happens in a different task, but for simulation I guess this is the best I can do..
		//runFlexFuelCalcs();
		//setCrankingInjectorPulseTime_FlexFuel();
		//extendedMode22PIDLookup();
		//engineControlGetFueling();
		delay_ms(1);
	

	}
	
	return 0;
	
}

#endif


void runFlexFuelCalcs(){
	
	
	calcTimingAdders();
	
	//Run the function we hijacked
	calculateLeadingTimingBase();

}


void initFlexFuelCalcs(){
	
	fuel_air_ratio = BASE_FUEL_AIR_RATIO;
	fuel_air_ratio_filtered = fuel_air_ratio;
	timing_mult = 0.0f;
	timing_adder_trailing = 0.0f;
	timing_adder_leading = 0.0f;
	ethanol_content_pcnt = 15.0f;
	ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
	flex_can_valid = 0;
	alive_count = 0U;
	fuel_air_ratio_FF = 0.002;
	timing_mult_FF = 0.002;
	//NOTE: This interface doesn't work and isn't known yet updateFaultStatus(flex_fault_index,FAULTED);
	flex_can_valid_prevLoop = flex_can_valid;
	cranking_fuel_mult = 1.0f;
	
		
}

void getEthanolContent(){
	
	//Simple data validity check, need to add a timeout fault etc
	if(((*can216rx_byte1 == (char)0x55) && (*can216rx_byte2 == (char)0xAA)) && *can_216_rx_timer != 0U){
		flex_can_valid = 1;
		
	}else{
		flex_can_valid = 0;
		
	}
	
	if(flex_can_valid){
		
		ethanol_content_pcnt = fixedPointToFloat_8bit_MULT_OFF_SIG(1.0f,0.0f,(int)*can216rx_byte0);
		ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		
	}else{
		
		//CAN timeout, go to value that is known, otherwise go to the last good RX'd value
		if(*can_216_rx_timer == 0U){
			
			//NOTE: I don't know how to handle this correctly, but probably but to just take the last known good value and set a fault
			//ethanol_content_pcnt = 15.0f;
			ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		}else{
			ethanol_content_pcnt = ethanol_content_last_valid_pcnt;
		}
		
	}
	
	
	//Set boundries
	saturate_SIGNAL_LOWER_UPPER(ethanol_content_pcnt,ETHANOL_CONTENT_MIN,ETHANOL_CONTENT_MAX);
	
	//get data			NOTE: TODO: May want to move this elsewhere
	getFlexMetrics();
	//Run the function we hijacked
	calculateGearRPMbased();
	
	flex_can_valid_prevLoop = flex_can_valid;
	
}

void getFlexMetrics(){
	
	//This is called in a ~16ms task rate in the ECU
	
	if((*engine_speed_rpm > ethanol_content_sample_thresh_rpm) || (*engine_load_g_rev > ethanol_content_sample_thresh_load)){
		//Do not update fueling or timing variables
	}else{
		fuel_air_ratio = Lookup2d(&ethanol_content_to_fuel_air_ratio_table_2d,ethanol_content_pcnt);
		timing_mult = Lookup2d(&ethanol_content_to_timing_mult,ethanol_content_pcnt);
	}
	
	//NOTE: Should probably turn into a ethanol content filter instead of filtering both signals
	fuel_air_ratio_filtered = firstOrderFilter_SIG_SIGPREV_MIN_FF(fuel_air_ratio,fuel_air_ratio_filtered, 0.018f, fuel_air_ratio_FF);
	timing_mult_filtered = firstOrderFilter_SIG_SIGPREV_MIN_FF(timing_mult,timing_mult_filtered, 0.018f, timing_mult_FF);
}

void getCrankingFuelMult(){
	
	cranking_fuel_mult =  Lookup3d(ethanol_content_pcnt,*coolant_temp_post_fault_detection_degC,&ethanol_content_to_cranking_fuel_3d);

	//Set boundries
	saturate_SIGNAL_LOWER_UPPER(cranking_fuel_mult,CRANKING_FUEL_MULT_MIN,CRANKING_FUEL_MULT_MAX);
}

void setCrankingInjectorPulseTime_FlexFuel(){
	//This function will overwrite the OEM function for cranking injector pulse time, so it is a copy of that function with added multipliers
	
	if(*engine_running_bool == 0){
		
		//getCrankingFuelMult(); // Not sure if this is the right place for this, but want to not run this function while engine is running
		
		*primary_fuel_injector_pulse_cranking = Lookup2d_unsigned(&oemInjectorCrankingPWTable,*coolant_temp_post_fault_detection_degC);
		*secondary_fuel_injector_pulse_cranking = 0.0f;
		
		//FlexFuel logic
		//*primary_fuel_injector_pulse_cranking = *primary_fuel_injector_pulse_cranking * cranking_fuel_mult;
		
	}
}


void flexCANUnpack(){
	
	//Unpack the CAN message however we woud like
	
	*can216rx_byte0 = *flex_message_byte0;
	*can216rx_byte1 = *flex_message_byte1;
	*can216rx_byte2 = *flex_message_byte2;
	
	return;
	
	//This function needs to be filled with something in the factory ROM, or else there is dead code running around
	//In theory not an issue, but...
	

}

void calcTimingAdders(){
	
	//Trailing
	timing_adder_trailing = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_trailing);
	timing_adder_trailing = timing_adder_trailing * timing_mult_filtered;
		
	//Leading
	timing_adder_leading = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_leading);
	timing_adder_leading = timing_adder_leading * timing_mult_filtered;
	
}

#ifdef USE_METRIC_CAN_PATCH

void can41GROMPack(){

	grom_can_tx_patch_tx_count = grom_can_tx_patch_tx_count + 1;
	
	//This should give this a 100ms tx rate
	if(grom_can_tx_patch_tx_count > 24){
		can41GROMGet();
		*can41TX_byte0 = 1;
		*can41TX_byte1 = 2;
		*can41TX_byte2 = 3;
		*can41TX_byte3 = 4;
		*can41TX_byte4 = 5;
		*can41TX_byte5 = 6;
		*can41TX_byte6 = 7;
		*can41TX_byte7 = 8;
		txCAN_EventBased(can_41_event_ID);		//this gives the pointer to the function
		grom_can_tx_patch_tx_count = 0;
	}
	
}


#endif



