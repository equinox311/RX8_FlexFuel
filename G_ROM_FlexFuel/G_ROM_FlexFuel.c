/***********************************************************************/
/*                                                                     */
/*  FILE        :TEST2.c                                               */
/*  DATE        :Thu, Jan 16, 2025                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :Other                                                 */
/*                                                                     */
/*  This file is generated by KPIT GNU Project Generator.              */
/*                                                                     */
/***********************************************************************/
         
																							
																							
#include "vars.h"


#define BASE_FUEL_AIR_RATIO			0.07196f
#define ETHANOL_CONTENT_MIN			0.0f
#define ETHANOL_CONTENT_MAX			100.0f

//Logging
#define EXTENDED_PID_SIZE			sizeof(extendo_pid)/sizeof(extendo_pid[2])		//TODO: Make this a sizeof call

//CAN setup
const CAN_Message_Setup_t flex_can_setup __attribute__ ((section ("FlexCANStruct"))) = {
	flex_sensor_id,
	0x1,
	0x22,
	0x8,
	0x0,
	flex_message_ram_start,
	0x1000000
};



//CAN unpack
void flexCANUnpack(void) __attribute__ ((section ("Flex_CAN_Unpack_Address")));


//Inits for flex based vars
void initFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Main for flex based function
void runFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Gets the ethanol content and applies to globals
void getFlexMetrics(void) __attribute__ ((section ("RomHole_ForCode")));

//Calculates timing adders
void calcTimingAdders(void) __attribute__ ((section ("RomHole_ForCode")));

//Get Ethanol Content from CAN message
void getEthanolContent(void) __attribute__ ((section ("RomHole_ForCode")));

//Extended logging parameter lookup
int extendedMode22PIDLookup (void) __attribute__ ((section ("RomHole_ForCode")));
void getEthanolContentMode22(char service) __attribute__ ((section ("RomHole_ForCode")));
void getFlexMultiplierMode22(char service) __attribute__ ((section ("RomHole_ForCode")));
void getFlexLeadingAdderMode22(char service) __attribute__ ((section ("RomHole_ForCode")));
void getFlexTrailingAdderMode22(char service) __attribute__ ((section ("RomHole_ForCode")));
void getFuelAirRatioFilteredMode22(char service) __attribute__ ((section ("RomHole_ForCode")));
void getOLFuelTargetMode22(char service) __attribute__ ((section ("RomHole_ForCode")));

//TODO: Move this to end of section
const Mode22_PID_t extendo_pid[6] __attribute__ ((section ("RomHole_ForPidStruct"))) = 
{
	{0x555,0x2,0x0,0xfffe,0x0000,&getEthanolContentMode22},			//0
	{0x22b,0x2,0x0,0xfffe,0x0000,&getFlexMultiplierMode22},			//1
	{0x557,0x2,0x0,0xfffe,0x0000,&getFlexLeadingAdderMode22},		//2
	{0x558,0x2,0x0,0xfffe,0x0000,&getFlexTrailingAdderMode22},		//3
	{0x559,0x2,0x0,0xfffe,0x0000,&getFuelAirRatioFilteredMode22},	//4
	{0x55A,0x2,0x0,0xfffe,0x0000,&getOLFuelTargetMode22}			//5
};


//Main function for ismulation

//#define NO_DEBUG

#ifdef NO_DEBUG
float func(void) __attribute__ ((section ("RomHole_ForCode")));
unsigned short i __attribute__ ((section ("RAMHole_forVariables"))) = 0U;
#endif

const float ethanol_content_sample_thresh_rpm __attribute__ ((section ("RomHole_calibrations"))) = 11000.0f;		//Default off
const float ethanol_content_sample_thresh_load __attribute__ ((section ("RomHole_calibrations"))) = 2.750f;			//Default off

//TODO: These need to not be random RAM vars
float fuel_air_ratio __attribute__ ((section ("RAMHole_forVariables"))); 
float fuel_air_ratio_filtered __attribute__ ((section ("RAMHole_forVariables"))); 
float timing_mult  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_trailing  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_leading  __attribute__ ((section ("RAMHole_forVariables"))); 
float ethanol_content_pcnt __attribute__ ((section ("RAMHole_forVariables")));
float ethanol_content_last_valid_pcnt __attribute__ ((section ("RAMHole_forVariables")));
char flex_can_valid __attribute__ ((section ("RAMHole_forVariables")));
char flex_can_valid_prevLoop __attribute__ ((section ("RAMHole_forVariables")));
long alive_count __attribute__ ((section ("RAMHole_forVariables")));
float fuel_air_ratio_FF __attribute__ ((section ("RAMHole_forVariables")));//16ms update rate ish
float timing_mult_filtered __attribute__ ((section ("RAMHole_forVariables")));
float timing_mult_FF __attribute__ ((section ("RAMHole_forVariables")));//16ms update rate ish


char flex_can_timeout_counts  __attribute__ ((section ("Flex_CAN_Timeout_Val"))) = 100; //30ms-ish task rate for can timers

//Setup patches for new adder pointers 
long timing_adder_trailing_ptr  __attribute__ ((section ("TrailingPointerPatch"))) = &timing_adder_trailing;
long timing_adder_leading_ptr __attribute__ ((section ("LeadingPointerPatch")))  = &timing_adder_leading;


#ifdef NO_DEBUG

void SetValues() __attribute__ ((section ("Misc")));

void SetValues() 
{
	
	*engine_load_g_rev = 0.02f;
	*engine_speed_rpm = 1000.0f;
	*coolant_temp_degC = 1.0f;
	ethanol_content_pcnt = 15.5f;
	*coolant_temp_post_fault_detection_degC = 85.0f;
	*flex_message_byte0 = 0x12;

}

void delay_ms(unsigned int ms)
{
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 1000; j++) {
            __asm("NOP");  // No Operation instruction, just to add some delay
        }
    }
}

float func(){
	
	//highLevelInit();
	initFlexFuelCalcs();
	while(1){
		//SetValues();
		getFlexMetrics();
		//flexCANUnpack();	//NOTE: This happens in a different task, but for simulation I guess this is the best I can do..

		int var = extendedMode22PIDLookup();
		i=i+1;
		if(i >= 255 && i < 256){
			i=0;
		}
	delay_ms(15);

	}
	
	return 0;
	
}

#endif


void runFlexFuelCalcs(){
	
	
	calcTimingAdders();
	
	//Run the function we hijacked
	calculateLeadingTimingBase();

}


void initFlexFuelCalcs(){
	
	fuel_air_ratio = BASE_FUEL_AIR_RATIO;
	fuel_air_ratio_filtered = fuel_air_ratio;
	timing_mult = 0.0f;
	timing_adder_trailing = 0.0f;
	timing_adder_leading = 0.0f;
	ethanol_content_pcnt = 15.0f;
	ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
	flex_can_valid = 0;
	alive_count = 0U;
	fuel_air_ratio_FF = 0.002;
	timing_mult_FF = 0.002;
	//NOTE: This interface doesn't work and isn't known yet updateFaultStatus(flex_fault_index,FAULTED);
	flex_can_valid_prevLoop = flex_can_valid;
}

void getEthanolContent(){
	
	//Simple data validity check, need to add a timeout fault etc
	if(((*can216rx_byte1 == (char)0x55) && (*can216rx_byte2 == (char)0xAA)) && *can_216_rx_timer != 0U){
		flex_can_valid = 1;
		
	}else{
		flex_can_valid = 0;
		
	}
	
	if(flex_can_valid){
		
		ethanol_content_pcnt = fixedPointToFloat_8bit_MULT_OFF_SIG(1.0f,0.0f,(int)*can216rx_byte0);
		ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		
	}else{
		
		//CAN timeout, go to value that is known, otherwise go to the last good RX'd value
		if(*can_216_rx_timer == 0U){
			
			//NOTE: I don't know how to handle this correctly, but probably but to just take the last known good value and set a fault
			//ethanol_content_pcnt = 15.0f;
			ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		}else{
			ethanol_content_pcnt = ethanol_content_last_valid_pcnt;
		}
		
	}
	
	
	//Set boundries
	if(ethanol_content_pcnt < ETHANOL_CONTENT_MIN){
		ethanol_content_pcnt = ETHANOL_CONTENT_MIN;
	}
	else if(ethanol_content_pcnt > ETHANOL_CONTENT_MAX){
		ethanol_content_pcnt = ETHANOL_CONTENT_MAX;
	}
	
	//get data			NOTE: TODO: May want to move this elsewhere
	getFlexMetrics();
	//Run the function we hijacked
	calculateGearRPMbased();
	
	flex_can_valid_prevLoop = flex_can_valid;
	
}

void getFlexMetrics(){
	
	//This is called in a ~16ms task rate in the ECU
	
	if((*engine_speed_rpm > ethanol_content_sample_thresh_rpm) || (*engine_load_g_rev > ethanol_content_sample_thresh_load)){
		//Do not update fueling or timing variables
	}else{
		fuel_air_ratio = Lookup2d(&ethanol_content_to_fuel_air_ratio_table_2d,ethanol_content_pcnt);
		timing_mult = Lookup2d(&ethanol_content_to_timing_mult,ethanol_content_pcnt);
	}
	
	//NOTE: Should probably turn into a ethanol content filter instead of filtering both signals
	fuel_air_ratio_filtered = firstOrderFilter_SIG_SIGPREV_MIN_FF(fuel_air_ratio,fuel_air_ratio_filtered, 0.018f, fuel_air_ratio_FF);
	timing_mult_filtered = firstOrderFilter_SIG_SIGPREV_MIN_FF(timing_mult,timing_mult_filtered, 0.018f, timing_mult_FF);
}


void flexCANUnpack(){
	
	//Unpack the CAN message however we woud like
	
	*can216rx_byte0 = *flex_message_byte0;
	*can216rx_byte1 = *flex_message_byte1;
	*can216rx_byte2 = *flex_message_byte2;
	
	//This is for function padding, though it likely doesn't matter... this shit is BAD
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");

}

void calcTimingAdders(){
	
	//Trailing
	timing_adder_trailing = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_trailing);
	timing_adder_trailing = timing_adder_trailing * timing_mult_filtered;
		
	//Leading
	timing_adder_leading = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_leading);
	timing_adder_leading = timing_adder_leading * timing_mult_filtered;
	
}



int extendedMode22PIDLookup(){
	
	int pid_array_count;
	char pid_found;
	int response_length;
	
	pid_array_count = 0;
	pid_found = 0;
	
	//G-ROM PID Lookup
	while(pid_array_count < 6 && pid_found == 0){
		
		if(extendo_pid[pid_array_count].pid_id == *uds_pid_data_rx_MAYBE){
			
			pid_found = 1;
	
			if((extendo_pid[pid_array_count].mem_mask_MAYBE & *pid_AND_val) == 0){
				
 				response_length = udsErrorResponse((char)0x22,(char)0x31);
				
			}else{
				if(*pid_id_greaterThan_1byte != (char)0x80){
					
					extendUDSDataReponse();
				}
				
				//Run function for PID
				extendo_pid[pid_array_count].function_ptr((char)0x22);
	
				if(*pid_id_greaterThan_1byte == 0){
				
					response_length = extendo_pid[pid_array_count].response_length + 3U;
					
				}else if(*pid_id_greaterThan_1byte == (char)0xff ){
					
					unknownMode22Func(0x22);
		         	response_length = udsErrorResponse((char)0x22,(char)0x22);

        		}
			}
		}
		
		pid_array_count++;
	}
	
	pid_array_count = 0;
	
	//OEM PID lookup
	while(pid_array_count < 110 && pid_found == 0){
		
		if(stock_pid_man[pid_array_count].pid_id == *uds_pid_data_rx_MAYBE){
			
			pid_found = 1;
	
			if((stock_pid_man[pid_array_count].mem_mask_MAYBE & *pid_AND_val) == 0){
				
 				response_length = udsErrorResponse((char)0x22,(char)0x31);
				
			}else{
				if(*pid_id_greaterThan_1byte != (char)0x80){
					
					extendUDSDataReponse();
				}
				
				//Run function for PID
				stock_pid_man[pid_array_count].function_ptr((char)0x22);
	
				if(*pid_id_greaterThan_1byte == 0){
				
					response_length = stock_pid_man[pid_array_count].response_length + 3U;
					
				}else if(*pid_id_greaterThan_1byte == (char)0xff ){
					
					unknownMode22Func(0x22);
		         	response_length = udsErrorResponse((char)0x22,(char)0x22);

        		}
			}
		}
		
		pid_array_count++;
	}
	
	if(pid_found == 0){
		response_length = udsErrorResponse((char)0x22,(char)0x31);
	}

	return response_length;
}


void getEthanolContentMode22(char service){
	
	unsigned int val;

	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(ethanol_content_pcnt,1.0f,0.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}

void getFlexMultiplierMode22(char service){
	
	unsigned int val;

	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(timing_mult_filtered,0.0005f,0.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}

void getFlexLeadingAdderMode22(char service){
	
	unsigned int val;

	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(timing_adder_leading,0.5f,-50.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}

void getFlexTrailingAdderMode22(char service){
	
	unsigned int val;

	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(timing_adder_trailing,0.5f,-50.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}

void getFuelAirRatioFilteredMode22(char service){
	
	unsigned int val;
	
	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(fuel_air_ratio_filtered,0.0000212f,0.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}

void getOLFuelTargetMode22(char service){
	
	unsigned int val;
	
	val = floatToFP_16bit_NUMBER_SCALAR_OFFSET(*lamda_request_final_ol,0.00003051758f,0.0f);
	intToUDS_SERVICE_DATA(service,val);
	
}




