/***********************************************************************/
/*                                                                     */
/*  FILE        :TEST2.c                                               */
/*  DATE        :Thu, Jan 16, 2025                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :Other                                                 */
/*                                                                     */
/*  This file is generated by KPIT GNU Project Generator.              */
/*                                                                     */
/***********************************************************************/
         
																							
																							
#include "vars.h"


#define BASE_FUEL_AIR_RATIO			0.07196f

#define ETHANOL_CONTENT_MIN			0.0f
#define ETHANOL_CONTENT_MAX			100.0f

//CAN setup
const CAN_Message_Setup_t flex_can_setup __attribute__ ((section ("FlexCANStruct"))) = {
	flex_sensor_id,
	0x1,
	0x22,
	0x8,
	0x0,
	flex_message_ram_start,
	0x1000000
};

//CAN unpack
void flexCANUnpack(void) __attribute__ ((section ("Flex_CAN_Unpack_Address")));


//Inits for flex based vars
void initFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Main for flex based function
void runFlexFuelCalcs(void) __attribute__ ((section ("RomHole_ForCode")));

//Gets the ethanol content and applies to globals
void getFlexMetrics(void) __attribute__ ((section ("RomHole_ForCode")));

//Calculates timing adders
void calcTimingAdders(void) __attribute__ ((section ("RomHole_ForCode")));

//Get Ethanol Content from CAN message
void getEthanolContent(void) __attribute__ ((section ("RomHole_ForCode")));


//Main function for ismulation
#ifdef NO_DEBUG
float func(void) __attribute__ ((section ("RomHole_ForCode")));
unsigned short i __attribute__ ((section ("RAMHole_forVariables"))) = 0U;
#endif

const float ethanol_content_sample_thresh_rpm __attribute__ ((section ("RomHole_calibrations"))) = 3100.0f;
const float ethanol_content_sample_thresh_load __attribute__ ((section ("RomHole_calibrations"))) = 0.750f;

//TODO: These need to not be random RAM vars
float fuel_air_ratio __attribute__ ((section ("RAMHole_forVariables"))); 
float timing_mult  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_trailing  __attribute__ ((section ("RAMHole_forVariables")));
float timing_adder_leading  __attribute__ ((section ("RAMHole_forVariables"))); 
float ethanol_content_pcnt __attribute__ ((section ("RAMHole_forVariables")));
float ethanol_content_last_valid_pcnt __attribute__ ((section ("RAMHole_forVariables")));
char flex_can_valid __attribute__ ((section ("RAMHole_forVariables")));
long alive_count __attribute__ ((section ("RAMHole_forVariables")));


char flex_can_timeout_counts  __attribute__ ((section ("Flex_CAN_Timeout_Val"))) = 100; //30ms-ish task rate for can timers

//Setup patches for new adder pointers 
long timing_adder_trailing_ptr  __attribute__ ((section ("TrailingPointerPatch"))) = &timing_adder_trailing;
long timing_adder_leading_ptr __attribute__ ((section ("LeadingPointerPatch")))  = &timing_adder_leading;


#ifdef NO_DEBUG

float func(){
	
	highLevelInit();
	
	while(1){
		flexCANUnpack();	//NOTE: This happens in a different task, but for simulation I guess this is the best I can do..
		engineControlCalculateTiming();
		
		i=i+1;
		if(i >= 255 && i < 256){
			i=0;
		}
		
	}
	
	return 0;
	
}

#endif


void runFlexFuelCalcs(){
	
	getFlexMetrics();
	calcTimingAdders();
	calculateLeadingTimingBase();

}


void initFlexFuelCalcs(){
	
	fuel_air_ratio = BASE_FUEL_AIR_RATIO;
	timing_mult = 0.0f;
	timing_adder_trailing = 0.0f;
	timing_adder_leading = 0.0f;
	ethanol_content_pcnt = 15.0f;
	ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
	flex_can_valid = 0;
	alive_count = 0x123U;	
}

void getEthanolContent(){
	
	//Simple data validity check, need to add a timeout fault etc
	if(((*can216rx_byte1 == (char)0x55) && (*can216rx_byte2 == (char)0xAA)) && *can_216_rx_timer != 0U){
		flex_can_valid = 1;
	}else{
		flex_can_valid = 0;
	}
	
	if(flex_can_valid){
		
		ethanol_content_pcnt = fixedPointToFloat_8bit_MULT_OFF_SIG(1.0f,0.0f,(int)*can216rx_byte0);
		ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		
	}else{
		
		//CAN timeout, go to value that is known, otherwise go to the last good RX'd value
		if(*can_216_rx_timer == 0U){
			ethanol_content_pcnt = 15.0f;
			ethanol_content_last_valid_pcnt = ethanol_content_pcnt;
		}else{
			ethanol_content_pcnt = ethanol_content_last_valid_pcnt;
		}
		
	}
	
	
	//Set boundries
	if(ethanol_content_pcnt < ETHANOL_CONTENT_MIN){
		ethanol_content_pcnt = ETHANOL_CONTENT_MIN;
	}
	else if(ethanol_content_pcnt > ETHANOL_CONTENT_MAX){
		ethanol_content_pcnt = ETHANOL_CONTENT_MAX;
	}
	
	//Run the function we hijacked
	calculateGearRPMbased();
	
	//Debug alive counter
	alive_count = alive_count + 1;
	if(alive_count >= 0xFFFE){
		alive_count = 0;
	}
}

void getFlexMetrics(){
	

	if((*engine_speed_rpm > ethanol_content_sample_thresh_rpm) || (*engine_load_g_rev > ethanol_content_sample_thresh_load)){
		//Do not update fueling or timing variables
	}else{
		fuel_air_ratio = Lookup2d(&ethanol_content_to_fuel_air_ratio_table_2d,ethanol_content_pcnt);
		timing_mult = Lookup2d(&ethanol_content_to_timing_mult,ethanol_content_pcnt);
	}
}


void flexCANUnpack(){
	
	//Unpack the CAN message however we woud like
	
	*can216rx_byte0 = *flex_message_byte0;
	*can216rx_byte1 = *flex_message_byte1;
	*can216rx_byte2 = *flex_message_byte2;
	
	//This is for function padding, though it likely doesn't matter... this shit is BAD
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");

}

void calcTimingAdders(){
	
	//Trailing
	timing_adder_trailing = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_trailing);
	timing_adder_trailing = timing_adder_trailing * timing_mult;
		
	//Leading
	timing_adder_leading = Lookup3d(*engine_load_g_rev,*engine_speed_rpm,&timing_ethanol_adder_leading);
	timing_adder_leading = timing_adder_leading * timing_mult;
	
}

#ifdef NO_DEBUG
void SetValues() __attribute__ ((section ("Misc")));

void SetValues() 
{
	
	*engine_load_g_rev = 0.02f;
	*engine_speed_rpm = 1000.0f;
	*coolant_temp_degC = 1.0f;
	//*ethanol_content_pcnt = 70.1f;
	*coolant_temp_post_fault_detection_degC = 85.0f;
	*flex_message_byte0 = 0x12;

}
#endif